# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Qiskit Development Team
# This file is distributed under the same license as the Qiskit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-31 13:06-0500\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../aqua/algorithms.rst:5
msgid "Algorithms"
msgstr ""

#: ../../aqua/algorithms.rst:7
msgid ""
"Aqua is an extensible collection of algorithms and utilities for use with"
" quantum computers to carry out research and investigate how to solve "
"problems using near-term quantum applications on short depth circuits. "
"The applications can span different domains. Aqua uses `Terra "
"<https://www.qiskit.org/terra>`__ for the generation, compilation and "
"execution of the quantum circuits modeling the specific problems."
msgstr ""

#: ../../aqua/algorithms.rst:14
msgid ""
"The following `quantum algorithms <#quantum-algorithms>`__ are part of "
"Aqua:"
msgstr ""

#: ../../aqua/algorithms.rst:16
msgid ":ref:`Variational Quantum Eigensolver (VQE)`"
msgstr ""

#: ../../aqua/algorithms.rst:17
msgid ":ref:`Quantum Approximate Optimization Algorithm (QAOA)`"
msgstr ""

#: ../../aqua/algorithms.rst:18
msgid ":ref:`Evolution of Hamiltonian (EOH)`"
msgstr ""

#: ../../aqua/algorithms.rst:19
msgid ":ref:`Quantum Phase Estimation (QPE)`"
msgstr ""

#: ../../aqua/algorithms.rst:20
msgid ":ref:`Iterative Quantum Phase Estimation (IQPE)`"
msgstr ""

#: ../../aqua/algorithms.rst:21
msgid ":ref:`Amplitude Estimation`"
msgstr ""

#: ../../aqua/algorithms.rst:22
msgid ":ref:`Quantum Grover Search`"
msgstr ""

#: ../../aqua/algorithms.rst:23
msgid ":ref:`Deutsch Jozsa`"
msgstr ""

#: ../../aqua/algorithms.rst:24
msgid ":ref:`Bernstein Vazirani`"
msgstr ""

#: ../../aqua/algorithms.rst:25
msgid ":ref:`Simon`"
msgstr ""

#: ../../aqua/algorithms.rst:26
msgid ":ref:`Support Vector Machine Quantum Kernel (QSVM Kernel)`"
msgstr ""

#: ../../aqua/algorithms.rst:27
msgid ":ref:`Support Vector Machine Variational (QSVM Variational)`"
msgstr ""

#: ../../aqua/algorithms.rst:29
msgid ""
"Aqua includes  also some `classical algorithms <#classical-reference-"
"algorithms>`__ for generating reference values. This feature of Aqua may "
"be useful to quantum algorithm researchers interested in generating, "
"comparing and contrasting results in the near term while experimenting "
"with, developing and testing quantum algorithms:"
msgstr ""

#: ../../aqua/algorithms.rst:35
msgid ":ref:`Exact Eigensolver`"
msgstr ""

#: ../../aqua/algorithms.rst:36
msgid ":ref:`CPLEX Ising`"
msgstr ""

#: ../../aqua/algorithms.rst:37
msgid ":ref:`Support Vector Machine Radial Basis Function Kernel (SVM Classical)`"
msgstr ""

msgid "Extending the Algorithm Library"
msgstr ""

#: ../../aqua/algorithms.rst:41
msgid ""
"Algorithms and many of the components they use have been designed to be "
"pluggable. A new algorithm may be developed according to the specific "
"Application Programming Interface (API) provided by Aqua, and by simply "
"adding its code to the collection of existing algorithms, that new "
"algorithm  will be immediately recognized via dynamic lookup, and made "
"available for use within the framework of Aqua. Specifically, to develop "
"and deploy any new algorithm, the new algorithm class should derive from "
"the ``QuantumAlgorithm`` class. Along with any supporting  module, for "
"immediate dynamic discovery, the new algorithm class can simply be placed"
" in an appropriate folder in the ``qiskit_aqua\\algorithms`` directory, "
"just like the existing algorithms.  Aqua also allows for :ref:`aqua-"
"dynamically-discovered-components`: new components can register "
"themselves as Aqua extensions and be dynamically discovered at run time "
"independent of their location in the file system. This is done in order "
"to encourage researchers and developers interested in :ref:`aqua-"
"extending` to extend the Aqua framework with their novel research "
"contributions."
msgstr ""

#: ../../aqua/algorithms.rst:60
msgid ""
"Section :ref:`aqua-extending` provides more details on how to extend Aqua"
" with new components."
msgstr ""

msgid "Multiple-Control Toffoli (MCT) Operation"
msgstr ""

#: ../../aqua/algorithms.rst:68
msgid ""
"The *Multiple-Control Toffoli (mct)* operation, as the name suggests, is "
"a generalization of the quantum Toffoli gate s.t. one target qubit is "
"controlled by an arbitrary number of control qubits for a NOT (`x`) "
"operation. The MCT operation can be used as the building block for "
"implementing various different quantum algorithms, such as Grover's "
"search algorithm."
msgstr ""

#: ../../aqua/algorithms.rst:75
msgid ""
"For the different numbers 0, 1, 2, … of controls, we have corresponding "
"quantum gates ``x``, ``cx``, ``ccx``, ... The first three are basic/well-"
"known quantum gates. In Aqua, the mct operation provides support for "
"arbitrary numbers of controls, in particular, 3 or above."
msgstr ""

#: ../../aqua/algorithms.rst:80
msgid ""
"Currently three different implementation strategies are included: "
"*basic*, *advanced*, and *noancilla*. The basic mode employs a textbook "
"implementation, where a series of ``ccx`` Toffoli gates are linked "
"together in a ``V`` shape to achieve the desired Multiple-Control Toffoli"
" operation. This mode requires :math:`n-2` ancillary qubits, where "
":math:`n` is the number of controls. For the advanced mode, the ``cccx`` "
"and ``ccccx`` operations are achieved without needing ancillary qubits. "
"Multiple-Control Toffoli operations for higher number of controls (5 and "
"above) are implemented recursively using these lower-number-of-control "
"cases. For the noancilla mode, no ancillary qubits are needed even for "
"higher number of controls. This uses a technique of spliting multiple-"
"control Toffoli operations, which is efficient up to 8 controls but gets "
"inefficient in the number of required basic gates for values above. This "
"technique relies on ``mcu1``, see :ref:`mcux` for more information."
msgstr ""

#: ../../aqua/algorithms.rst:96
msgid ""
"Aqua's mct operation can be invoked from a ``QuantumCircuit`` object "
"using the ``mct`` API, which expects a list ``q_controls`` of control "
"qubits, a target qubit ``q_target``, and a list ``q_ancilla`` of "
"ancillary qubits. An optional keyword argument ``mode`` can also be "
"passed in to indicate whether the ``'basic'``, ``'advanced'``, or "
"``'noancilla'`` mode is chosen. If omitted, this argument defaults to "
"``'basic'``."
msgstr ""

msgid "Multiple-Control U1 and U3 Rotation (MCU1 and MCU3) Operation"
msgstr ""

#: ../../aqua/algorithms.rst:108
msgid ""
"The *Multiple-Control Rotation (mcu)* operation, implements a U1 (`u1`) "
"or a U3 (`u3`) rotation gate on a single target qubit with an arbitrary "
"number of control qubits. The MCU1 operation takes one rotation angle as "
"input parameter, whereas the MCU3 operation takes three for arbitrary "
"rotations. No ancillary qubits are needed. It is efficiently implemented "
"by using a grey code sequence for up to 8 control qubits. For larger "
"number of controls this implementation gets very inefficient."
msgstr ""

#: ../../aqua/algorithms.rst:116
msgid ""
"Aqua's mcu1 and mcu3 operations can be invoked from a ``QuantumCircuit`` "
"object and expect a list ``control_qubits`` of control qubits and a "
"target qubit ``target_qubit`` as well as an angle ``theta`` for the mcu1 "
"and additionally two angles ``phi`` and ``lam`` for the mcu3."
msgstr ""

#: ../../aqua/algorithms.rst:126
msgid "Quantum Algorithms"
msgstr ""

#: ../../aqua/algorithms.rst:128
msgid ""
"In this section, we describe the quantum algorithms currently available "
"in Aqua."
msgstr ""

#: ../../aqua/algorithms.rst:132
msgid ""
"Aqua requires associating a quantum device or simulator to any experiment"
" that uses a quantum algorithm.  This is done by configuring the "
"``\"backend\"`` section of the experiment to be run. Consult the "
"documentation on the :ref:`aqua-input-file` for more details."
msgstr ""

#: ../../aqua/algorithms.rst:140
msgid "Variational Quantum Eigensolver (VQE)"
msgstr ""

#: ../../aqua/algorithms.rst:142
msgid ""
"`VQE <https://arxiv.org/abs/1304.3061>`__ is a hybrid algorithm that uses"
" the variational approach and interleaves quantum and classical "
"computations in order to find the minimum eigenvalue of the Hamiltonian "
":math:`H` of a given system. An instance of VQE requires defining two "
"algorithmic subcomponents: a trial function from Aqua's :ref"
":`variational-forms` library, and a classical optimizer from Aqua's "
":ref:`optimizers` library.  An initial state from Aqua's :ref:`initial-"
"states` library may be supplied too in order to define the starting state"
" for the trial function."
msgstr ""

#: ../../aqua/algorithms.rst:153
msgid ""
"Refer to the documentation of :ref:`variational-forms`, :ref:`optimizers`"
" and :ref:`initial-states` for more details."
msgstr ""

#: ../../aqua/algorithms.rst:156
msgid "Additionally, VQE can be configured with the following parameters:"
msgstr ""

#: ../../aqua/algorithms.rst:158 ../../aqua/algorithms.rst:221
msgid ""
"A ``str`` value indicating the mode used by the ``Operator`` class for "
"the computation:"
msgstr ""

#: ../../aqua/algorithms.rst:164 ../../aqua/algorithms.rst:227
msgid ""
"If no value for ``operator_mode`` is specified, the default is "
"``\"matrix\"``."
msgstr ""

#: ../../aqua/algorithms.rst:166 ../../aqua/algorithms.rst:237
msgid "The initial point for the search of the minimum eigenvalue:"
msgstr ""

#: ../../aqua/algorithms.rst:172
msgid ""
"An optional list of ``float`` values  may be provided as the starting "
"point for the search of the minimum eigenvalue. This feature is "
"particularly useful when there are reasons to believe that the solution "
"point is close to a particular point, which can then be provided as the "
"preferred initial point.  As an example, when building the dissociation "
"profile of a molecule, it is likely that using the previous computed "
"optimal solution as the starting initial point for the next interatomic "
"distance is going to reduce the number of iterations necessary for the "
"variational algorithm to converge.  Aqua provides `a tutorial detailing "
"this use case <https://github.com/Qiskit/aqua-"
"tutorials/blob/master/chemistry/h2_vqe_initial_point.ipynb>`__."
msgstr ""

#: ../../aqua/algorithms.rst:180
msgid ""
"The length of the ``initial_point`` list value must match the number of "
"the parameters expected by the variational form being used. If the user "
"does not supply a preferred initial point, then VQE will look to the "
"variational form for a preferred value. If the variational form returns "
"``None``, then a random point will be generated within the parameter "
"bounds set, as per above. If the variational form provides ``None`` as "
"the lower bound, then VQE will default it to :math:`-2\\pi`; similarly, "
"if the variational form returns ``None`` as the upper bound, the default "
"value will be :math:`2\\pi`."
msgstr ""

msgid "Declarative Name"
msgstr ""

#: ../../aqua/algorithms.rst:190
msgid ""
"When referring to VQE declaratively inside Aqua, its code ``name``, by "
"which Aqua dynamically discovers and loads it, is ``VQE``."
msgstr ""

msgid "Problems Supported"
msgstr ""

#: ../../aqua/algorithms.rst:195
msgid "In Aqua, VQE supports the ``energy`` and ``ising`` problems."
msgstr ""

#: ../../aqua/algorithms.rst:201
msgid "Quantum Approximate Optimization Algorithm (QAOA)"
msgstr ""

#: ../../aqua/algorithms.rst:203
msgid ""
"`QAOA <https://arxiv.org/abs/1411.4028>`__ is a well-known algorithm for "
"finding approximate solutions to combinatorial-optimization problems. The"
" QAOA implementation in Aqua directly uses `VQE <#variational-quantum-"
"eigensolver-vqe>`__ for its general hybrid optimization structure. "
"However, unlike VQE, which can be configured with arbitrary variational "
"forms, QAOA uses its own fine-tuned variational form, which comprises "
":math:`p` parameterized global :math:`x` rotations and :math:`p` "
"different parameterizations of the problem hamiltonian. As a result, "
"unlike VQE, QAOA does not need to have a variational form specified as an"
" input parameter, and is configured mainly by a single integer parameter,"
" ``p``, which dictates the depth of the variational form, and thus "
"affects the approximation quality. An initial state from Aqua's :ref"
":`initial-states` library may be supplied as well."
msgstr ""

#: ../../aqua/algorithms.rst:217
msgid "Consult the documentation on :ref:`optimizers` for more details."
msgstr ""

#: ../../aqua/algorithms.rst:219
msgid "In summary, QAOA can be configured with the following parameters:"
msgstr ""

#: ../../aqua/algorithms.rst:229
msgid ""
"A positive ``int`` value configuring the QAOA variational form depth, as "
"discussed above:"
msgstr ""

#: ../../aqua/algorithms.rst:235
msgid "This has to be a positive ``int`` value.  The default is ``1``."
msgstr ""

#: ../../aqua/algorithms.rst:243
msgid ""
"An optional list of :math:`2p` ``float`` values  may be provided as the "
"starting ``beta`` and ``gamma`` parameters (as identically named in the "
"original `QAOA paper <https://arxiv.org/abs/1411.4028>`__) for the QAOA "
"variational form. If such list is not provided, QAOA will simply start "
"with the all-zero vector."
msgstr ""

#: ../../aqua/algorithms.rst:247
msgid "Similar to VQE, an optimizer may also be specified."
msgstr ""

#: ../../aqua/algorithms.rst:251
msgid ""
"When referring to QAOA declaratively inside Aqua, its code ``name``, by "
"which Aqua dynamically discovers and loads it, is ``QAOA.Variational``."
msgstr ""

#: ../../aqua/algorithms.rst:257
msgid "In Aqua, QAOA supports the ``ising`` problem."
msgstr ""

#: ../../aqua/algorithms.rst:263
msgid "Evolution of Hamiltonian (EOH)"
msgstr ""

#: ../../aqua/algorithms.rst:265
msgid ""
"EOH provides the lower-level building blocks for simulating universal "
"quantum systems. For any given quantum system that can be decomposed into"
" local interactions (for example, a global hamiltonian as the weighted "
"sum of several Pauli spin operators), the local interactions can then be "
"used to approximate the global quantum system via, for example, Lloyd’s "
"method or Trotter-Suzuki decomposition."
msgstr ""

#: ../../aqua/algorithms.rst:274
msgid "This algorithm only supports the local state vector simulator."
msgstr ""

#: ../../aqua/algorithms.rst:276
msgid "EOH can be configured with the following parameter settings:"
msgstr ""

#: ../../aqua/algorithms.rst:278
msgid "Evolution time:"
msgstr ""

#: ../../aqua/algorithms.rst:284
msgid ""
"A ``float`` value is expected.  The minimum value is ``0.0``.  The "
"default value is ``1.0``."
msgstr ""

#: ../../aqua/algorithms.rst:286
msgid "The evolution mode of the computation:"
msgstr ""

#: ../../aqua/algorithms.rst:292
msgid ""
"Two ``str`` values are permitted: ``\"matrix\"`` or ``\"circuit\"``, with"
" ``\"circuit\"`` being the default."
msgstr ""

#: ../../aqua/algorithms.rst:294 ../../aqua/algorithms.rst:357
msgid "The number of time slices:"
msgstr ""

#: ../../aqua/algorithms.rst:300
msgid "This has to be a non-negative ``int`` value.  The default is ``1``."
msgstr ""

#: ../../aqua/algorithms.rst:302 ../../aqua/algorithms.rst:365
msgid "The expansion mode:"
msgstr ""

#: ../../aqua/algorithms.rst:308 ../../aqua/algorithms.rst:371
msgid ""
"Two ``str`` values are permitted: ``\"trotter\"`` (Lloyd's method) or "
"``\"suzuki\"`` (for Trotter-Suzuki expansion), with  ``\"trotter\"`` "
"being the default one."
msgstr ""

#: ../../aqua/algorithms.rst:311 ../../aqua/algorithms.rst:374
msgid "The expansion order:"
msgstr ""

#: ../../aqua/algorithms.rst:317 ../../aqua/algorithms.rst:380
msgid ""
"This parameter sets the Trotter-Suzuki expansion order.  A positive "
"``int`` value is expected.  The default value is ``2``."
msgstr ""

#: ../../aqua/algorithms.rst:321
msgid ""
"When referring to EOH declaratively inside Aqua, its code ``name``, by "
"which Aqua dynamically discovers and loads it, is ``EOH``."
msgstr ""

#: ../../aqua/algorithms.rst:326
msgid "In Aqua, EOH supports the ``eoh`` problem."
msgstr ""

#: ../../aqua/algorithms.rst:332
msgid "Quantum Phase Estimation (QPE)"
msgstr ""

#: ../../aqua/algorithms.rst:334
msgid ""
"QPE (also sometimes abbreviated as PEA, for *Phase Estimation "
"Algorithm*), takes two quantum registers, *control* and *target*, where "
"the control consists of several qubits initially put in uniform "
"superposition, and the target a set of qubits prepared in an eigenstate "
"(or, oftentimes, a guess of the eigenstate) of the unitary operator of a "
"quantum system. QPE then evolves the target under the control using "
":ref:`Dynamics` on the unitary operator. The information of the "
"corresponding eigenvalue is then *kicked-back* into the phases of the "
"control register, which can then be deconvoluted by an Inverse Quantum "
"Fourier Transform (IQFT), and measured for read-out in binary decimal "
"format.  QPE also requires a reasonably good estimate of the eigen wave "
"function to start the process. For example, when estimating molecular "
"ground energies, the :ref:`Hartree-Fock` method could be used to provide "
"such trial eigen wave functions."
msgstr ""

#: ../../aqua/algorithms.rst:351
msgid ""
"Consult the documentation on :ref:`iqfts` and :ref:`initial-states` for "
"more details."
msgstr ""

#: ../../aqua/algorithms.rst:354
msgid ""
"In addition to requiring an IQFT and an initial state as part of its "
"configuration, QPE also exposes the following parameter settings:"
msgstr ""

#: ../../aqua/algorithms.rst:363
msgid "This has to be a non-negative ``int`` value.  The default value is ``1``."
msgstr ""

#: ../../aqua/algorithms.rst:382
msgid "The number of ancillae:"
msgstr ""

#: ../../aqua/algorithms.rst:388
msgid ""
"This parameter sets the number of ancillary qubits to be used by QPE.  A "
"positive ``int`` value is expected. The default value is ``1``."
msgstr ""

#: ../../aqua/algorithms.rst:393
msgid ""
"When referring to QPE declaratively inside Aqua, its code ``name``, by "
"which Aqua dynamically discovers and loads it, is ``QPE``."
msgstr ""

#: ../../aqua/algorithms.rst:398
msgid "In Aqua, QPE supports the ``energy`` problem."
msgstr ""

#: ../../aqua/algorithms.rst:404
msgid "Iterative Quantum Phase Estimation (IQPE)"
msgstr ""

#: ../../aqua/algorithms.rst:406
msgid ""
"IQPE, as its name suggests, iteratively computes the phase so as to "
"require fewer qubits. It takes in the same set of parameters as `QPE "
"<#quantum-phase-estimation-qpe>`__, except for the number of ancillary "
"qubits ``num_ancillae``, which is replaced by ``num_iterations`` (a "
"positive ``int``, also defaulted to ``1``), and for the fact that an "
"Inverse Quantum Fourier Transform (IQFT) is not used for IQPE."
msgstr ""

#: ../../aqua/algorithms.rst:415
msgid ""
"For more details, please see `arXiv:quant-ph/0610214 "
"<https://arxiv.org/abs/quant-ph/0610214>`__."
msgstr ""

#: ../../aqua/algorithms.rst:419
msgid ""
"When referring to IQPE declaratively inside Aqua, its code ``name``, by "
"which Aqua dynamically discovers and loads it, is ``IQPE``."
msgstr ""

#: ../../aqua/algorithms.rst:424
msgid "In Aqua, IQPE supports the ``energy`` problem."
msgstr ""

#: ../../aqua/algorithms.rst:431
msgid "Amplitude Estimation"
msgstr ""

#: ../../aqua/algorithms.rst:433
msgid ""
"*Amplitude Estimation* is a derivative of -  :ref:`Quantum Phase "
"Estimation (QPE)` applied to a particular operator :math:`A`. :math:`A` "
"is assumed to operate on :math:`n + 1` qubits (plus possible ancillary "
"qubits) where the :math:`n` qubits represent the uncertainty (in the form"
" of a random distribution from the :ref:`random-distributions` library) "
"and the last qubit, called the *objective qubit*, is used to represent "
"the normalized objective value as its amplitude. In other words, "
":math:`A` is constructed such that the probability of measuring a '1' in "
"the objective qubit is equal to the value of interest."
msgstr ""

#: ../../aqua/algorithms.rst:445
msgid ""
"Consult the documentation on -  :ref:`Quantum Phase Estimation (QPE)` for"
" more details. Also, see `arXiv:1806.06893 "
"<https://arxiv.org/abs/1806.06893>`_ for more details on Amplitude "
"Estimation as well as its applications on finance problems."
msgstr ""

#: ../../aqua/algorithms.rst:449
msgid ""
"In addition to relying on a ``QPE`` component for building the Quantum "
"Phase Estimation circuit, in order to be properly constructed, an "
"``AmplitudeEstimation`` algorithm object expects the following inputs:"
msgstr ""

#: ../../aqua/algorithms.rst:454
msgid "The number of evaluation qubits:"
msgstr ""

#: ../../aqua/algorithms.rst:460
msgid "This has to be a positive ``int`` value."
msgstr ""

#: ../../aqua/algorithms.rst:462
msgid "The uncertainty problem:"
msgstr ""

#: ../../aqua/algorithms.rst:468
msgid ""
"A ``CircuitFactory`` object that represents the uncertainty problem, "
"i.e., the :math:`A` operator mentioned above."
msgstr ""

#: ../../aqua/algorithms.rst:470
msgid "The optional problem unitary:"
msgstr ""

#: ../../aqua/algorithms.rst:476
msgid ""
"An optional ``CircuitFactory`` object that represents the problem "
"unitary, which, if left unspecified, will be automatically constructed "
"from the ``a_factory``."
msgstr ""

#: ../../aqua/algorithms.rst:479
msgid "The Inverse Quantum Fourier Transform component:"
msgstr ""

#: ../../aqua/algorithms.rst:485
msgid ""
"The Inverse Quantum Fourier Transform pluggable component that's to be "
"used to configure the ``PhaseEstimation`` component. The standard iqft "
"will be used by default if left None."
msgstr ""

#: ../../aqua/algorithms.rst:491
msgid ""
"When referring to Amplitude Estimation declaratively inside Aqua, its "
"code ``name``, by which Aqua dynamically discovers and loads it, is "
"``AmplitudeEstimation``."
msgstr ""

#: ../../aqua/algorithms.rst:496
msgid "In Aqua, Amplitude Estimation supports the ``uncertainty`` problem."
msgstr ""

#: ../../aqua/algorithms.rst:503
msgid "Quantum Grover Search"
msgstr ""

#: ../../aqua/algorithms.rst:505
msgid ""
"Grover’s Search is a well known quantum algorithm for searching through "
"unstructured collections of records for particular targets with quadratic"
" speedup compared to classical algorithms."
msgstr ""

#: ../../aqua/algorithms.rst:509
msgid ""
"Given a set :math:`X` of :math:`N` elements "
":math:`X=\\{x_1,x_2,\\ldots,x_N\\}` and a boolean function :math:`f : X "
"\\rightarrow \\{0,1\\}`, the goal on an *unstructured-search problem* is "
"to find an element :math:`x^* \\in X` such that :math:`f(x^*)=1`. "
"Unstructured search is often alternatively formulated as a database "
"search problem, in which, given a database, the goal is to find in it an "
"item that meets some specification. The search is called *unstructured* "
"because there are no guarantees as to how the database is ordered.  On a "
"sorted database, for instance, one could perform binary search to find an"
" element in :math:`\\mathbb{O}(\\log N)` worst-case time. Instead, in an "
"unstructured-search problem, there is no prior knowledge about the "
"contents of the database. With classical circuits, there is no "
"alternative but to perform a linear number of queries to find the target "
"element. Conversely, Grover’s Search algorithm allows to solve the "
"unstructured-search problem on a quantum computer in "
":math:`\\mathcal{O}(\\sqrt{N})` queries."
msgstr ""

#: ../../aqua/algorithms.rst:525
msgid ""
"All that is needed for carrying out a search is an Grover oracle from "
"Aqua's :ref:`oracles` library for specifying the search criterion, which "
"basically indicates a hit or miss for any given record.  More formally, "
"an Grover *oracle* :math:`O_f` is an object implementing a boolean "
"function :math:`f` as specified above.  Given an input :math:`x \\in X`, "
":math:`O_f` returns :math:`f(x)`.  The details of how :math:`O_f` works "
"are unimportant; Grover's search algorithm treats the oracle as a black "
"box. Currently, Aqua provides the :ref:`sat`, which takes as input a SAT "
"problem in `DIMACS CNF format <http://www.satcompetition.org/2009/format-"
"benchmarks2009.html>`__ and constructs the corresponding quantum circuit."
"  Grover oracles are treated as pluggable components in Aqua; researchers"
" interested in :ref:`aqua-extending` can design and implement new Grover "
"oracles and extend Aqua's Grover oracle library."
msgstr ""

#: ../../aqua/algorithms.rst:540
msgid "Grover is configured with the following parameter settings:"
msgstr ""

#: ../../aqua/algorithms.rst:542
msgid "Number of iterations:"
msgstr ""

#: ../../aqua/algorithms.rst:548
msgid ""
"For the conventional Grover's search algorithm, the parameter "
"``num_iterations`` is used to specify how many times the marking and "
"reflection phase sub-circuit is repeated to amplify the amplitude(s) of "
"the target(s). A positive ``int`` value is expected. The default value is"
" ``1``."
msgstr ""

#: ../../aqua/algorithms.rst:554
msgid "Incremental mode flag:"
msgstr ""

#: ../../aqua/algorithms.rst:560
msgid ""
"When run in ``incremental`` mode, the search task will be carried out in "
"successive rounds, using circuits built with incrementally higher number "
"of iterations for the repetition of the amplitude amplification until a "
"target is found or the maximal number :math:`\\log N` (:math:`N` being "
"the total number of elements in the set from the oracle used) of "
"iterations is reached. The implementation follows Section 4 of `Boyer et "
"al. <https://arxiv.org/abs/quant-ph/9605034>`__ The ``incremental`` "
"boolean flag defaults to ``False``. When set ``True``, the other "
"parameter ``num_iterations`` will be ignored."
msgstr ""

#: ../../aqua/algorithms.rst:574
msgid ""
"When referring to Quantum Grover Search declaratively inside Aqua, its "
"code ``name``, by which Aqua dynamically discovers and loads it, is "
"``Grover``."
msgstr ""

#: ../../aqua/algorithms.rst:579
msgid "In Aqua, Grover's Search algorithm supports the ``search`` problem."
msgstr ""

#: ../../aqua/algorithms.rst:585
msgid "Deutsch-Jozsa"
msgstr ""

#: ../../aqua/algorithms.rst:587
msgid ""
"The Deutsch-Jozsa algorithm was one of the first known quantum algorithms"
" that showed an exponential speedup compared to a deterministic (non-"
"probabilistic) classical algorithm, given a black box oracle function. "
"The algorithm determines whether the given function :math:`f:\\{0,1\\}^n "
"\\rightarrow \\{0,1\\}` is constant or balanced. A constant function maps"
" all inputs to 0 or 1, and a balanced function maps half of its inputs to"
" 0 and the other half to 1. The oracle implementation can be found at "
":ref:`djoracle`"
msgstr ""

#: ../../aqua/algorithms.rst:598
msgid ""
"When referring to Deutsch-Jozsa declaratively inside Aqua, its code "
"``name``, by which Aqua dynamically discovers and loads it, is "
"``DeutschJozsa``."
msgstr ""

#: ../../aqua/algorithms.rst:604
msgid ""
"In Aqua, the Deutsch-Jozsa algorithm supports the ``functionevaluation`` "
"problem."
msgstr ""

#: ../../aqua/algorithms.rst:611
msgid "Bernstein-Vazirani"
msgstr ""

#: ../../aqua/algorithms.rst:613
msgid ""
"The Bernstein-Vazirani algorithm is an extension / restriction of the "
"Deutsch-Jozsa algorithm. The goal of the algorithm is to determine a "
"secret string :math:`s \\in \\{0,1\\}^n`, given a black box oracle "
"function that maps :math:`f:\\{0,1\\}^n \\rightarrow \\{0,1\\}` such that"
" :math:`f(x)=s \\cdot x (\\bmod 2)`. The oracle implementation can be "
"found at :ref:`bvoracle`."
msgstr ""

#: ../../aqua/algorithms.rst:622
msgid ""
"When referring to Bernstein-Vazirani declaratively inside Aqua, its code "
"``name``, by which Aqua dynamically discovers and loads it, is "
"``BernsteinVazirani``."
msgstr ""

#: ../../aqua/algorithms.rst:628
msgid ""
"In Aqua, the Bernstein-Vazirani algorithm supports the "
"``hiddenstringfinding`` problem."
msgstr ""

#: ../../aqua/algorithms.rst:635
msgid "Simon"
msgstr ""

#: ../../aqua/algorithms.rst:637
msgid ""
"The Simon algorithm finds a hidden integer :math:`s \\in \\{0,1\\}^n` "
"from an oracle :math:`f_s` that satisfies :math:`f_s(x) = f_s(y)` if and "
"only if :math:`y=x \\oplus s` for all :math:`x \\in \\{0,1\\}^n`. Thus, "
"if :math:`s = 0\\ldots 0`, i.e., the all-zero bitstring, then :math:`f_s`"
" is a 1-to-1 (or, permutation) function. Otherwise, if :math:`s \\neq "
"0\\ldots 0`, then :math:`f_s` is a 2-to-1 function. The oracle "
"implementation can be found at :ref:`simonoracle`."
msgstr ""

#: ../../aqua/algorithms.rst:647
msgid ""
"When referring to Simon declaratively inside Aqua, its code ``name``, by "
"which Aqua dynamically discovers and loads it, is ``Simon``."
msgstr ""

#: ../../aqua/algorithms.rst:652
msgid "In Aqua, the Simon algorithm supports the ``periodfinding`` problem."
msgstr ""

#: ../../aqua/algorithms.rst:659
msgid "Support Vector Machine Quantum Kernel (QSVM Kernel)"
msgstr ""

#: ../../aqua/algorithms.rst:661
msgid ""
"Classification algorithms and methods for machine learning are essential "
"for pattern recognition and data mining applications. Well known "
"techniques, such as support vector machines or neural networks, have "
"blossomed over the last two decades as a result of the spectacular "
"advances in classical hardware computational capabilities and speed. This"
" progress in computer power made it possible to apply techniques "
"theoretically developed towards the middle of the XX century on "
"classification problems that soon became increasingly challenging."
msgstr ""

#: ../../aqua/algorithms.rst:670
msgid ""
"A key concept in classification methods is that of a kernel. Data cannot "
"typically be separated by a hyperplane in its original space. A common "
"technique used to find such a hyperplane consists on applying a non-"
"linear transformation function to the data. This function is called a "
"*feature map*, as it transforms the raw features, or measurable "
"properties, of the phenomenon or subject under study. Classifying in this"
" new feature space – and, as a matter of fact, also in any other space, "
"including the raw original one – is nothing more than seeing how close "
"data points are to each other. This is the same as computing the inner "
"product for each pair of data in the set. In fact we do not need to "
"compute the non-linear feature map for each datum, but only the inner "
"product of each pair of data points in the new feature space. This "
"collection of inner products is called the *kernel* and it is perfectly "
"possible to have feature maps that are hard to compute but whose kernels "
"are not."
msgstr ""

#: ../../aqua/algorithms.rst:686
msgid ""
"The QSVM Kernel algorithm applies to classification problems that require"
" a feature map for which computing the kernel is not efficient "
"classically. This means that the required computational resources are "
"expected to scale exponentially with the size of the problem. QSVM Kernel"
" uses a Quantum processor to solve this problem by a direct estimation of"
" the kernel in the feature space. The method used falls in the category "
"of what is called *supervised learning*, consisting of a *training phase*"
" (where the kernel is calculated and the support vectors obtained) and a "
"*test or classification phase* (where new labelless data is classified "
"according to the solution found in the training phase)."
msgstr ""

#: ../../aqua/algorithms.rst:697
msgid ""
"QSVM Kernel can be configured with a ``bool`` parameter, indicating "
"whether or not to print additional information when the algorithm is "
"running:"
msgstr ""

#: ../../aqua/algorithms.rst:704
msgid "The default is ``False``."
msgstr ""

#: ../../aqua/algorithms.rst:708
msgid ""
"When referring to QSVM Kernel declaratively inside Aqua, its code "
"``name``, by which Aqua dynamically discovers and loads it, is "
"``QSVM.Kernel``."
msgstr ""

#: ../../aqua/algorithms.rst:713
msgid "In Aqua, QSVM Kernel  supports the ``svm_classification`` problem."
msgstr ""

#: ../../aqua/algorithms.rst:719
msgid "Support Vector Machine Variational (QSVM Variational)"
msgstr ""

#: ../../aqua/algorithms.rst:721
msgid ""
"Just like QSVM Kernel, the QSVM Variational algorithm applies to "
"classification problems that require a feature map for which computing "
"the kernel is not efficient classically. QSVM Variational uses the "
"variational method to solve such problems in a quantum processor.  "
"Specifically, it optimizes a parameterized quantum circuit to provide a "
"solution that cleanly separates the data."
msgstr ""

#: ../../aqua/algorithms.rst:728
msgid "QSVM Variational can be configured with the following parameters:"
msgstr ""

#: ../../aqua/algorithms.rst:730
msgid "The depth of the variational circuit to be optimized:"
msgstr ""

#: ../../aqua/algorithms.rst:736
msgid ""
"An integer value greater than or equal to ``3`` is expected.  The default"
" is ``3``."
msgstr ""

#: ../../aqua/algorithms.rst:738
msgid ""
"A Boolean indicating whether or not to print additional information when "
"the algorithm is running:"
msgstr ""

#: ../../aqua/algorithms.rst:744
msgid "A ``bool`` value is expected.  The default is ``False``."
msgstr ""

#: ../../aqua/algorithms.rst:748
msgid ""
"When referring to QSVM Variational declaratively inside Aqua, its code "
"``name``, by which Aqua dynamically discovers and loads it, is "
"``QSVM.Variational``."
msgstr ""

#: ../../aqua/algorithms.rst:753
msgid "In Aqua, QSVM Variational  supports the ``svm_classification`` problem."
msgstr ""

#: ../../aqua/algorithms.rst:759
msgid "Classical Reference Algorithms"
msgstr ""

#: ../../aqua/algorithms.rst:761
msgid ""
"In this section, we describe the classical algorithms currently available"
" in Aqua. While these algorithms do not use a quantum device or "
"simulator, and rely on purely classical approaches, they may be useful in"
" the near term to generate reference values while experimenting with, "
"developing and testing quantum algorithms."
msgstr ""

#: ../../aqua/algorithms.rst:769
msgid ""
"Aqua prevents associating a quantum device or simulator to any experiment"
" that uses a classical algorithm.  The ``\"backend\"`` section of an "
"experiment to be conducted via a classical algorithm is disabled."
msgstr ""

#: ../../aqua/algorithms.rst:777
msgid "Exact Eigensolver"
msgstr ""

#: ../../aqua/algorithms.rst:779
msgid ""
"Exact Eigensolver computes up to the first :math:`k` eigenvalues of a "
"complex square matrix of dimension :math:`n \\times n`, with :math:`k "
"\\leq n`. It can be configured with an ``int`` parameter ``k`` indicating"
" the number of eigenvalues to compute:"
msgstr ""

#: ../../aqua/algorithms.rst:787
msgid ""
"Specifically, the value of this parameter must be an ``int`` value ``k`` "
"in the range :math:`[1,n]`. The default is ``1``."
msgstr ""

#: ../../aqua/algorithms.rst:791
msgid ""
"When referring to Exact Eigensolver declaratively inside Aqua, its code "
"``name``, by which Aqua dynamically discovers and loads it, is "
"``ExactEigensolver``."
msgstr ""

#: ../../aqua/algorithms.rst:796
msgid ""
"In Aqua, Exact Eigensolver supports the ``energy``, ``ising`` and "
"``excited_states``  problems."
msgstr ""

#: ../../aqua/algorithms.rst:802
msgid "CPLEX Ising"
msgstr ""

#: ../../aqua/algorithms.rst:804
msgid ""
"This algorithm uses the `IBM ILOG CPLEX Optimization Studio "
"<https://www.ibm.com/support/knowledgecenter/SSSA5P_12.8.0/ilog.odms.studio.help/Optimization_Studio/topics/COS_home.html>`__,"
" which should be installed along with its `Python API "
"<https://www.ibm.com/support/knowledgecenter/SSSA5P_12.8.0/ilog.odms.cplex.help/CPLEX/GettingStarted/topics/set_up/Python_setup.html>`__"
" for this algorithm to be operational. This algorithm currently supports "
"computing the energy of an Ising model Hamiltonian."
msgstr ""

#: ../../aqua/algorithms.rst:811
msgid "CPLEX Ising can be configured with the following parameters:"
msgstr ""

#: ../../aqua/algorithms.rst:813
msgid "A time limit in seconds for the execution:"
msgstr ""

#: ../../aqua/algorithms.rst:819
msgid "A positive ``int`` value is expected.  The default value is `600`."
msgstr ""

#: ../../aqua/algorithms.rst:821
msgid "The number of threads that CPLEX uses:"
msgstr ""

#: ../../aqua/algorithms.rst:827
msgid ""
"A non-negative ``int`` value is expected. Setting ``thread`` to ``0`` "
"lets CPLEX decide the number of threads to allocate, but this may not be "
"ideal for small problems.  Any value greater than ``0`` specifically sets"
" the thread count.  The default value is ``1``, which is ideal for small "
"problems."
msgstr ""

#: ../../aqua/algorithms.rst:831
msgid ""
"Decides what CPLEX reports to the screen and records in a log during "
"mixed integer optimization (MIP)."
msgstr ""

#: ../../aqua/algorithms.rst:837
msgid ""
"An ``int`` value between ``0`` and ``5`` is expected. The amount of "
"information displayed increases with increasing values of this parameter."
" By default, this value is set to ``2``."
msgstr ""

#: ../../aqua/algorithms.rst:843
msgid ""
"When referring to CPLEX Ising declaratively inside Aqua, its code "
"``name``, by which Aqua dynamically discovers and loads it, is "
"``CPLEX.Ising``."
msgstr ""

#: ../../aqua/algorithms.rst:848
msgid "In Aqua, CPLEX supports the ``ising`` problem."
msgstr ""

#: ../../aqua/algorithms.rst:853
msgid "Support Vector Machine Radial Basis Function Kernel (SVM Classical)"
msgstr ""

#: ../../aqua/algorithms.rst:855
msgid ""
"SVM Classical uses a classical approach to experiment with feature map "
"classification problems. SVM Classical can be configured with a ``bool`` "
"parameter, indicating whether or not to print additional information when"
" the algorithm is running:"
msgstr ""

#: ../../aqua/algorithms.rst:864
msgid "The default value for this parameter is ``False``."
msgstr ""

#: ../../aqua/algorithms.rst:868
msgid ""
"When referring to SVM Classical declaratively inside Aqua, its code "
"``name``, by which Aqua dynamically discovers and loads it, is ``SVM``."
msgstr ""

#: ../../aqua/algorithms.rst:873
msgid "In Aqua, SVM Classical supports the ``svm_classification`` problem."
msgstr ""


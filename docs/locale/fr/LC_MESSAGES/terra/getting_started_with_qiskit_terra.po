# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Qiskit Development Team
# This file is distributed under the same license as the Qiskit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-31 13:06-0500\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../terra/getting_started_with_qiskit_terra.rst:5
msgid "Getting Started with Qiskit"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:7
msgid ""
"Here, we provide an overview of working with Qiskit. Qiskit provides the "
"basic building blocks necessary to program quantum computers. The "
"foundation of Qiskit is the Terra element. The basic concept of Qiskit "
"Terra is an array of quantum circuits. A workflow using Terra consists of"
" two stages: **Build** and **Execute**. **Build** allows you to make "
"different quantum circuits that represent the problem you are solving, "
"and **Execute** allows you to run them on different backends. After the "
"jobs have been run, the data is collected. There are methods for putting "
"this data together, depending on the program. This either gives you the "
"answer you wanted, or allows you to make a better program for the next "
"instance."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:19
msgid "**Contents**"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:21
msgid "`Circuit basics <#circuit_basics>`__"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:23
msgid "`Simulating circuits with Qiskit Aer <#aer_simulation>`__"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:25
msgid "`Running circuits using the IBMQ provider <#ibmq_provider>`__"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:27
msgid "**Code imports**"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:36
msgid "Circuit Basics"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:39
msgid "Building the circuit"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:41
msgid ""
"The basic elements needed for your first program are the QuantumCircuit, "
"and QuantumRegister."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:56
msgid "Note: Naming the QuantumRegister is optional and not required."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:62
msgid ""
"After you create the circuit with its registers, you can add gates "
"(“operations”) to manipulate the registers. As you proceed through the "
"documentation you will find more gates and circuits; below is an example "
"of a quantum circuit that makes a three-qubit GHZ state"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:67
msgid "|\\psi\\rangle = \\left(|000\\rangle+|111\\rangle\\right)/\\sqrt{2}."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:69
msgid ""
"To create such a state, we start with a 3-qubit quantum register. By "
"default, each qubit in the register is initialized to :math:`|0\\rangle`."
" To make the GHZ state, we apply the following gates: \\* A Hadamard gate"
" :math:`H` on qubit 0, which puts it into a superposition state. \\* A "
"controlled-Not operation (:math:`C_{X}`) between qubit 0 and qubit 1. \\*"
" A controlled-Not operation between qubit 0 and qubit 2."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:76
msgid ""
"On an ideal quantum computer, the state produced by running this circuit "
"would be the GHZ state above."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:79
msgid ""
"In Qiskit Terra, operations can be added to the circuit one-by-one, as "
"shown below."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:103
msgid "Visualize Circuit"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:105
msgid ""
"You can visualize your circuit using Qiskit Terra "
"``QuantumCircuit.draw()``, which plots circuit in the form found in many "
"textbooks."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:128
msgid ""
"In this circuit, the qubits are put in order with qubit zero at the top "
"and qubit two at the bottom. The circuit is read left-to-right (meaning "
"that gates which are applied earlier in the circuit show up further to "
"the left)."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:134
msgid "Simulating circuits using Qiskit Aer"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:136
msgid ""
"Qiskit Aer is our package for simulating quantum circuits. It provides "
"many different backends for doing a simulation. Here we use the basic "
"python version."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:141
msgid "Statevector backend"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:143
msgid ""
"The most common backend in Qiskit Aer is the ``statevector_simulator``. "
"This simulator returns the quantum state which is a complex vector of "
"dimensions :math:`2^n` where :math:`n` is the number of qubits (so be "
"careful using this as it will quickly get too large to run on your "
"machine)."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:153
msgid ""
"When representing the state of a multi-qubit system, the tensor order "
"used in qiskit is different than that use in most physics textbooks. "
"Suppose there are :math:`n` qubits, and qubit :math:`j` is labeled as "
":math:`Q_{j}`. In most textbooks (such as Nielsen and Chuang’s “Quantum "
"Computation and Information”), the basis vectors for the :math:`n`-qubit "
"state space would be labeled as :math:`Q_{0}\\otimes Q_{1} \\otimes "
"\\cdots \\otimes Q_{n}`. **This is not the ordering used by qiskit!** "
"Instead, qiskit uses an ordering in which the :math:`n^{\\mathrm{th}}` "
"qubit is on the *left* side of the tesnsor product, so that the basis "
"vectors are labeled as :math:`Q_n\\otimes \\cdots \\otimes Q_1\\otimes "
"Q_0`."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:165
msgid ""
"For example, if qubit zero is in state 0, qubit 1 is in state 0, and "
"qubit 2 is in state 1, qiskit would represent this state as "
":math:`|100\\rangle`, whereas most physics textbooks would represent it "
"as :math:`|001\\rangle`."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:170
msgid ""
"This difference in labeling affects the way multi-qubit operations are "
"represented as matrices. For example, qiskit represents a controlled-X "
"(:math:`C_{X}`) operation with qubit 0 being the control and qubit 1 "
"being the target as"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:175
msgid ""
"C_X = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\  0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 &"
" 0 \\\\ 0 & 1 & 0 & 0 \\\\\\end{pmatrix}."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:181
msgid ""
"To run the above circuit using the statevector simulator, first you need "
"to import Aer and then set the backend to ``statevector_simulator``."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:192
msgid ""
"Now we have chosen the backend it’s time to compile and run the quantum "
"circuit. In Qiskit Terra we provide the ``execute`` function for this. "
"``execute`` returns a ``job`` object that encapsulates information about "
"the job submitted to the backend."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:201
msgid ""
"Tip: You can obtain the above parameters in Jupyter. Simply place the "
"text cursor on a function and press Shift+Tab."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:213
msgid ""
"When you run a program, a job object is made that has the following two "
"useful methods: ``job.status()`` and ``job.result()`` which return the "
"status of the job and a result object respectively."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:221
msgid ""
"Note: Jobs run asynchronously but when the result method is called it "
"switches to synchronous and waits for it to finish before moving on to "
"another task."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:233
msgid ""
"The results object contains the data and Qiskit Terra provides the method"
" ``result.get_statevector(circ)`` to return the state vector for the "
"quantum circuit."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:249
msgid ""
"Qiskit Terra also provides a visualization toolbox to allow you to view "
"these results."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:252
msgid ""
"Below, we use the visualization function to plot the real and imaginary "
"components of the state vector."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:268
msgid "Unitary backend"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:270
msgid ""
"Qiskit Aer also includes a ``unitary_simulator`` that works *provided all"
" the elements in the circuit are unitary operations*. This backend "
"calculates the :math:`2^n \\times 2^n` matrix representing the gates in "
"the quantum circuit."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:307
msgid "OpenQASM backend"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:309
msgid ""
"The simulators above are useful because they provide information about "
"the state output by the ideal circuit and the matrix representation of "
"the circuit. However, a real experiment terminates by *measuring* each "
"qubit (usually in the computational :math:`|0\\rangle, |1\\rangle` "
"basis). Without measurement, we cannot gain information about the state. "
"Measurements cause the quantum system to collapse into classical bits."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:316
msgid ""
"For example, suppose we make independent measurements on each qubit of "
"the three-qubit GHZ state"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:319
msgid "|\\psi\\rangle = |000\\rangle +|111\\rangle)/\\sqrt{2},"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:321
msgid ""
"and let :math:`xyz` denote the bitstring that results. Recall that, under"
" the qubit labeling used by Qiskit, :math:`x` would correspond to the "
"outcome on qubit 2, :math:`y` to the outcome on qubit 1, and :math:`z` to"
" the outcome on qubit 0. This representation of the bitstring puts the "
"most significant bit (MSB) on the left, and the least significant bit "
"(LSB) on the right. This is the standard ordering of binary bitstrings. "
"We order the qubits in the same way, which is why Qiskit uses a non-"
"standard tensor product order."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:330
msgid "The probability of obtaining outcome :math:`xyz` is given by"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:332
msgid "\\mathrm{Pr}(xyz) = |\\langle xyz | \\psi \\rangle |^{2}."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:334
msgid ""
"By explicit computation, we see there are only two bitstrings that will "
"occur: :math:`000` and :math:`111`. If the bitstring :math:`000` is "
"obtained, the state of the qubits is :math:`|000\\rangle`, and if the "
"bitstring is :math:`111`, the qubits are left in the state "
":math:`|111\\rangle`. The probability of obtaining 000 or 111 is the "
"same; namely, 1/2:"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:341
msgid ""
"\\begin{align} \\mathrm{Pr}(000) &= |\\langle 000 | \\psi \\rangle |^{2} "
"= \\frac{1}{2}\\\\ \\mathrm{Pr}(111) &= |\\langle 111 | \\psi \\rangle "
"|^{2} = \\frac{1}{2}. \\end{align}"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:348
msgid ""
"To simulate a circuit that includes measurement, we need to add "
"measurements to the original circuit above, and use a different Aer "
"backend."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:390
msgid ""
"This circuit adds a classical register, and three measurements that are "
"used to map the outcome of qubits to the classical bits."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:393
msgid ""
"To simulate this circuit, we use the ``qasm_simulator`` in Qiskit Aer. "
"Each run of this circuit will yield either the bitstring 000 or 111. To "
"build up statistics about the distribution of the bitstrings (to, e.g., "
"estimate :math:`\\mathrm{Pr}(000)`), we need to repeat the circuit many "
"times. The number of times the circuit is repeated can be specified in "
"the ``execute`` function, via the ``shots`` keyword."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:413
msgid ""
"Once you have a result object, you can access the counts via the function"
" ``get_counts(circuit)``. This gives you the *aggregated* binary outcomes"
" of the circuit you submitted."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:428
msgid ""
"Approximately 50 percent of the time the output bitstring is 000. Qiskit "
"Terra also provides a function ``plot_histogram`` which allows you to "
"view the outcomes."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:444
msgid ""
"The estimated outcome probabilities :math:`\\mathrm{Pr}(000)` and "
":math:`\\mathrm{Pr}(111)` are computed by taking the aggregate counts and"
" dividing by the number of shots (times the circuit was repeated). Try "
"changing the ``shots`` keyword in the ``execute`` function and see how "
"the estimated probabilities change."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:451
msgid "Running circuits using the IBMQ provider"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:453
msgid ""
"To faciliate access to real quantum computing hardware, we have provided "
"a simple API interface. To access IBMQ devices, you’ll need an API token."
" For the public IBM Q devices, you can generate an API token `here "
"<https://quantumexperience.ng.bluemix.net/qx/account/advanced>`__ (create"
" an account if you don’t already have one). For Q Network devices, login "
"to the q-console, click your hub, group, and project, and expand “Get "
"Access” to generate your API token and access url."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:461
msgid ""
"Our IBMQ provider lets you run your circuit on real devices or on our HPC"
" simulator. Currently, this provider exists within Qiskit, and can be "
"imported as shown below. For details on the provider, see `The IBMQ "
"Provider <the_ibmq_provider.ipynb>`__."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:470
msgid ""
"After generating your API token, call, ``IBMQ.save_account('MY_TOKEN')``."
" For Q Network users, you’ll also need to include your access url: "
"``IBMQ.save_account('MY_TOKEN', 'URL')``"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:474
msgid ""
"This will store your IBMQ credentials in a local file. Unless your "
"registration information has changed, you only need to do this once. You "
"may now load your accounts by calling,"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:482
msgid ""
"Once your account has been loaded, you can view the list of backends "
"available to you."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:509
msgid "Running circuits on real devices"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:511
msgid ""
"Today’s quantum information processors are small and noisy, but are "
"advancing at a fast pace. They provide a great opportunity to explore "
"what `noisy, intermediate-scale quantum (NISQ) "
"<https://arxiv.org/abs/1801.00862>`__ computers can do."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:516
msgid ""
"The IBMQ provider uses a queue to allocate the devices to users. We now "
"choose a device with the least busy queue which can support our program "
"(has at least 3 qubits)."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:535
msgid ""
"To run the circuit on the backend, we need to specify the number of shots"
" and the number of credits we are willing to spend to run the circuit. "
"Then, we execute the circuit on the backend using the ``execute`` "
"function."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:556
msgid ""
"``job_exp`` has a ``.result()`` method that lets us get the results from "
"running our circuit."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:563
msgid ""
"Note: When the .result() method is called, the code block will wait until"
" the job has finished before releasing the cell."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:574
msgid ""
"Like before, the counts from the execution can be obtained using "
"``get_counts(qc)``"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:590
msgid "Simulating circuits using a HPC simulator"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:592
msgid ""
"The IBMQ provider also comes with a remote optimized simulator called "
"``ibmq_qasm_simulator``. This remote simulator is capable of simulating "
"up to 32 qubits. It can be used the same way as the remote real backends."
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:625
msgid "Retrieving a previously ran job"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:627
msgid ""
"If your experiment takes longer to run then you have time to wait around,"
" or if you simply want to retrieve old jobs back, the IBMQ backends allow"
" you to do that. First you would need to note your job’s ID:"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:644
msgid ""
"Given a job ID, that job object can be later reconstructed from the "
"backend using retrieve_job:"
msgstr ""

#: ../../terra/getting_started_with_qiskit_terra.rst:651
msgid "and then the results can be obtained from the new job object."
msgstr ""

